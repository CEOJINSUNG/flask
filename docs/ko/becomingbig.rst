.. _becomingbig:

크게 만들기
===========

코드가 증가하고 어플리케이션의 규모가 커질 때 여러분에게 몇가지 선택사항이 있다.

소스코드를 읽어라.
------------------

Flask는 이미 존재하고 잘 사용되는 도구인 Werkzeug(WSGI)와 Jinja(템플릿 엔진)
을 기반으로, 여러분 자신의 프레임워크를 만들기 위한 방법을 설명하기 위해 부분적으로
시작되었고, 개발되어오면서, 넓은 사용자층에게 유용해졌다. 여러분의 코드가 점점
커진다면, 단지 Flask를 사용하지만 말고, 소스 코드를 읽어 Flask에 대해 이해하라.
Flask의 소스 코드는 읽기 좋게 쓰여져 있다. Flask의 명세는 공개되어 있으므로 누구든 Flask의
내부 API를 사용할 수 있다. Flask는 상위 라이브러리의 문서화된 API만 사용하고,
이들의 내부 유틸리티들을 문서화하기 때문에 여러분의 프로젝트에 필요한 훅 포인트(hook point)를
찾을 수 있다.

훅(Hook)하고. 확장하라.
-----------------------

:ref:`api` 문서는 사용가능한 오버라이드, 훅 포인트, :ref:`signals` 로 가득 차 있다.
여러분은 요청과 응답 객체와 같은 것에 대한 커스텀 클래스를 제공할 수 있다. 여러분이
사용하는 API에 대해 좀 더 깊게 파보고, Flask 릴리즈에 특별하게 사용가능한
커스터마이징된 것을 찾아봐라.  여러분의 프로젝트가 여러 유틸리티나 Flask 확장 기능으로
리팩토링될 수 있는 방식을 찾아봐라.  커뮤니티에 있는 여러
`확장 기능 <http://flask.pocoo.org/extensions/>`_ 을 살펴보고 , 여러분이 필요한 도구를
찾을 수 없다면 여러분 자신의 확장 기능을 만들기 위한 패턴을 찾아봐라.

서브클래싱하라.
---------------

:class:`~flask.Flask` 클래스는 서브클래싱에 대해 설계된 여러 메소드가 있다.
여러분은 :class:`~flask.Flask` (연결된 메소드 문서를 살펴봐라) 를
서브클래싱하고 어플리케이션 클래스를 인스턴스화한 곳 어디서나 그 서브클래스를
사용하여 동작을 빠르게 추가하거나 커스터마이징할 수 있다.  이것은
:ref:`app-factories` 과 함께 잘 동작한다.

미들웨어로 감싸라.
------------------

:ref:`app-dispatch` 장에서 미들웨어를 적용하는 방법에 대해 자세히 보여줬다.
여러분의 Flask 인스턴스를 감싸기 위해 WSGI 미들웨어와 여러분의 어플리케이션
과 HTTP 서버 사이에 있는 계층에 수정과 변경을 소개할 수 있다. Werkzeug는
다수의 `미들웨어 <http://werkzeug.pocoo.org/docs/middlewares/>`_ 를 포함하고 있다.

분기(fork)하라.
---------

위에서 언급한 선택사항 중 어느 것에도 해당되지 않는다면, Flask를 분기해라.
Flask 코드의 다수는 Werkzeug와 Jinja2 안에 있는 것이다.  이런 라이브러리가
그 동작의 대다수를 수행한다.  Flask는 단지 그런 라이브러리를 잘 붙여논
풀같은 것이다.  어떤 프로젝트던, 사용하는 프레임워크가 방해가 될 때가 있다.
(이는 프레임워크를 개발한 개발자들의 가정들 때문이다.) 이것은 자연스러운 것이다.
만약 그렇지 않다면, 그 프레임워크는 시작부터 굉장히 가파른 학습 곡선 때문에 많은
개발자의 좌절감을 유발하는 매우 복잡한 시스템이 될 것이다.

이것은 Flask에만 유일하게 적용되지 않는다.  많은 사람들이 그들이 사용하는
프레임워크의 단점에 대응하기 위해 패치되고 변경된 버전의 프레임워크를 사용한다.
이 방식 또한 Flask의 라이선스에 반영되어 있다.  여러분이 Flask를 수정해서
사용하기로 결정했더라도 그 어떤 변경에 대해서도 의무적으로 기여하지 않아도 된다.

Flask를 분기해서 사용할 때의 단점으로, Flask의 확장 기능들이 대부분 깨질 것이란 점이다.
왜냐하면 새로운 프레임워크는 다른 임포트 명을 가질 것이기 때문이다.
더 나아가, 변경의 개수의 따라 상위 변경을 통합하는 것이 복합한 과정일
수 있다. 이와 같은 이유들 때문에 분기하는 것은 최후의 보루가 되어야 할 것이다.

프로페셔널처럼 규모를 조절하라.
-------------------------------

많은 웹 어플리케이션에 대한 코드의 복잡도는 예상되는 사용자 수와 데이터
항목에 대한 규모를 조절하는것에 비하면 큰 이슈는 아니다.  Flask
그 자체로는 여러분의 어플리케이션 코드, 사용하고자 하는 데이타 저장소 그리고
실행되는 파이썬 구현과 웹서버에 의한 규모 조절이라는 측면에서만 제한된다.

예를 들어, 규모를 잘 조절한다는 것은 만약 여러분이 서버의 양을 두배로 했을 때
두배의 성능을 얻는다는 것을 의미한다.  규모 조절이 잘못됐다는 것은 여러분이
새로운 서버를 추가했을 때 어플리케이션이 더 좋은 성능을 내지 못하거나 심지어
대체되는 서버로 지원하지도 못하는 것을 의미한다.

콘텍스트 로컬 프록시(context local proxy)가 Flask에서 규모 조절과 관련된 유일한 제한 요소이다.
그것들은 Flask에 있는 쓰레드, 프로세스 혹은 greenlet으로 정의되는 콘텍스트에 의존한다.
여러분의 서버가 쓰레드 또는 그린렛에 기반하지 않은 어떤 동시성(concurrency)의
기능을 사용한다면, Flask는 더이상 이와 같은 전역 프록시를 제공할 수 없을 것이다.
하지만 대다수 서버는, Werkzeug 라이브러리가 잘 지원하는 모든 방법의 동시성을 달성하기 위해
쓰레드, greenlet, 프로세스 분리 중 하나의 방법을 사용하고 있다.

프로세스를 사용할 것이다.

커뮤니티에서 논의하라.
--------------------

Flask 개발자들은 코드의 크기와 상관없이 모든 사용자가 프레임워크에 접근할
수 있도록 유지하는 역할을 한다. 개발 도중 Flask로 인한 어떤 걸림돌을 만난다면
Flask 개발자들에게 메일링 리스트나 IRC 채널을 통해 망설이지 말고 연락해라.
Flask 및 Flask 확장 기능의 개발자들이 더 큰 어플리케이션을 위한 툴을
개선하는 가장 좋은 방법은 사용자들에게 직접 피드백을 얻는 것이다.
